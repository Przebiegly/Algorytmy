<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

</head>

<style>
    table {
        width: 100%;
        height: 100vh;
        border-collapse: collapse;
    }

    td {
        border: 1px solid #ddd;
        padding: 10px;
        text-align: center;
    }


    img {
        max-width: 1000px;
        max-height: 600px;
        min-width: 700px;
    }

    ol li {
        list-style-position: inside;
    }
</style>

<body>
    <table>
        <tr>
            <td>
                <p><b>
                        Sortowanie przez wstawianie
                    </b></p>
                <ol>
                    <li>Przejdź przez zbiór od drugiego elementu do ostatniego.</li>
                    <li>Wybierz bieżący element i oznacz go jako element do wstawienia.</li>
                    <li>Porównaj wybrany element z elementami wcześniejszymi, zaczynając od elementu bezpośrednio przed
                        nim.</li>
                    <li>Jeżeli istnieje element przed elementem wybranym i jest od niego większy, przesuń ten element w
                        prawo.</li>
                    <li>Wstaw wybrany element w miejsce "dziury" powstałej po przesunięciu elementów większych.</li>
                    <li> Powtarzaj kroki 2-5 dla każdego kolejnego elementu w zbiorze. </li>
                    <li>Zakończ proces sortowania i wyeksportuj uporządkowany zbiór danych </li>
                </ol>
            </td>
            <td>
                <img src="sortowanie_przez_Wstawianie.png" alt="Image 1">
            </td>
            <td>
                <img src="sortowanie_przez_Wstawianie_code.png" alt="Image 2">
            </td>
        </tr>


        <tr>
            <td>
                <p>
                    <b>Sortowanie przez wybieranie</b>
                </p>
                <ol>
                    <li>Przejdź przez cały zestaw danych, porównując sąsiednie elementy.</li>
                    <li>Jeśli sąsiadujące ze sobą elementy są w złej kolejności (np. element poprzedni jest większy od
                        następnego), zamień je miejscami.</li>
                    <li>Powtórz krok 1 dla wszystkich pozostałych elementów, aż dotrzesz do ostatniej pary elementów.
                    </li>
                    <li>Po zakończeniu pierwszej iteracji największy element powinien znaleźć się na końcu kolekcji.
                    </li>
                    <li>Powtórz kroki 1-4 dla n-1 elementów, gdzie n jest rozmiarem kolekcji.</li>
                    <li>Po zakończeniu wszystkich iteracji, cała kolekcja powinna być uporządkowana rosnąco.</li>
                </ol>

            </td>
            <td>
                <img src="przez_wybieranie.png" alt="Image 1">
            </td>
            <td>
                <img src="przez_wybieranie_code.png" alt="Image 2">
            </td>
        </tr>

        <tr>
            <td>
                <p>
                    <b>Quicksort</b>
                </p>
                <ol>
                    <li>Wybierz element ze zbioru jako punkt odniesienia, który nazywamy osią (pivot). Może to być
                        dowolny element, na przykład pierwszy, ostatni lub losowy element.</li>
                    <li>Podziel zbiór na dwie części: elementy mniejsze od osi i elementy większe od osi.</li>
                    <li>Przenieś wszystkie elementy mniejsze od osi na lewą stronę, a wszystkie elementy większe od osi
                        na prawą stronę.</li>
                    <li>Rekurencyjnie zastosuj kroki 1-3 dla obu podzbiorów, tj. dla zbioru elementów mniejszych od osi
                        oraz dla zbioru elementów większych od osi.</li>
                    <li>Po zakończeniu rekurencyjnych wywołań sortowania, wszystkie podzbiory zostaną uporządkowane.
                    </li>
                    <li>Połącz podzbiory, umieszczając najpierw podzbiór elementów mniejszych od osi, następnie samą oś
                        i na końcu podzbiór elementów większych od osi.</li>
                </ol>

            </td>
            <td>
                <img src="quicksort_j.png" alt="Image 1">
            </td>
            <td>
                <img src="QuickSort.png" alt="Image 2">
            </td>
        </tr>

        <tr>
            <td>
                <p>
                    <b>Sortowanie przez scalanie</b>
                </p>
                <ol>
                    <li>Jeśli zbiór zawiera jeden lub zero elementów, jest już posortowany. Zwróć ten zbiór.</li>
                    <li>Podziel zbiór na dwie połowy.</li>
                    <li>Rekurencyjnie zastosuj algorytm sortowania przez scalanie dla każdej z połówek.</li>
                    <li>Scalaj posortowane połówki w celu utworzenia posortowanego zbioru:

                    <li>Utwórz nową tablicę lub listę, która będzie przechowywać scalone elementy.</li>
                    <li>Porównuj elementy z obu połówek, zaczynając od ich początków.</li>
                    <li>Dodawaj mniejszy element do scalanej tablicy/listy.</li>
                    <li>Jeśli jedna z połówek zostanie już w pełni przeanalizowana, dodaj pozostałe elementy z
                        drugiej połowy do scalanej tablicy/listy.</li>
                    <li>Powtarzaj te kroki, aż obie połówki zostaną w pełni rozwiązane i wszystkie elementy
                        zostaną umieszczone w scalonej tablicy/liście.</li>

                    </li>
                    <li>Zwróć scalony zbiór.</li>
                </ol>

            </td>
            <td>
                <img src="przez_scalanie.png" alt="Image 1">
            </td>
            <td>
                <img src="sortowanie przez scalanie.png" alt="Image 2">
            </td>
        </tr>



        <tr>
            <td>
                <p><b>Sortowanie bąbelkowe</b>
                </p>
                <ol>
                    <li>Przejdź przez cały zestaw danych, porównując sąsiednie elementy.</li>
                    <li>Jeśli sąsiadujące ze sobą elementy są w złej kolejności (np. element poprzedni jest większy od
                        następnego), zamień je miejscami.</li>
                    <li>Powtórz krok 1 dla wszystkich pozostałych elementów, aż dotrzesz do ostatniej pary elementów.
                    </li>
                    <li>Po zakończeniu pierwszej iteracji największy element powinien znaleźć się na końcu kolekcji.
                    </li>
                    <li>Powtórz kroki 1-4 dla n-1 elementów, gdzie n jest rozmiarem kolekcji.</li>
                    <li>Po zakończeniu wszystkich iteracji, cała kolekcja powinna być uporządkowana rosnąco.</li>
                </ol>

            </td>
            <td>
                <img src="bombelkowe.png" alt="Image 1">
            </td>
            <td>
                <img src="bombelkowe_code.png" alt="Image 2">
            </td>
        </tr>


    </table>

</body>

</html>